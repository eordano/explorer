type GlobalDCL = {
  onLog: any
  onError: any
  onStartFunctions: any
  onUpdateFunctions: any
  onEventFunctions: any
  rendererInterface: any
  loadedAPIs: any
  loadAPIs: any
  fireEvent: any
}
export function BuildDCLInterface(globalObject: any) {
  const that = globalObject as GlobalDCL
  return {
    DEBUG: true,
    log(...args: any[]) {
      that.onLog(...args)
    },

    /**
     * Subscribe to ticks generated by the Gamekit class.
     * @param cb
     */
    onUpdate(cb: (deltaTime: number) => void): void {
      if (typeof (cb as any) !== 'function') {
        that.onError(new Error('onUpdate only takes a function as argument'))
      } else {
        that.onUpdateFunctions.push(cb)
      }
    },

    // @TODO (eordano, 31/Aug/2019): Make this interface friendlier and more efficient.

    /**
     * Subscribe to *all* events received by the kernel as well as the ECS engine.
     * @param cb
     */
    onEvent(cb: (event: any) => void): void {
      if (typeof (cb as any) !== 'function') {
        that.onError(new Error('onEvent only takes a function as argument'))
      } else {
        that.onEventFunctions.push(cb)
      }
    },

    /**
     * Notify the kernel that we are interested in receiving events of a certain name.
     * See IEvents for a list of possible event names
     * @param eventName
     */
    subscribe(eventName: string): void {
      that.rendererInterface.subscribe(eventName)
      that.rendererInterface.on(eventName, (event: any) => {
        that.fireEvent({ type: eventName, data: event.data })
      })
    },

    /**
     * Notify the engine that events with this name are no longer necessary.
     * @see {subscribe}
     * @param eventName
     */
    unsubscribe(eventName: string): void {
      that.rendererInterface.unsubscribe(eventName)
    },

    loadModule: (moduleName: string) => {
      const moduleToLoad = moduleName.replace(/^@decentraland\//, '')
      try {
        return that.loadAPIs([moduleToLoad])[moduleToLoad].then((proxy: any) => {
          return proxy._getExposedMethods().then((methods: any) => {
            return {
              rpcHandle: moduleToLoad,
              methods: methods.map((name: string) => ({ name }))
            }
          })
        })
      } catch (e) {
        e.message = `Could not get the methods of ${moduleToLoad} -- ` + e.message
        throw e
      }
    },

    callRpc: (rpcHandle: string, methodName: string, args: any[]) => {
      const api = that.loadedAPIs[rpcHandle]
      if (!api) {
        throw new Error(`callRPC error: ${rpcHandle} has not been loaded. Did you forget to call \`loadModule\`?`)
      }
      if (!api[methodName]) {
        throw new Error(
          `callRPC error: ${rpcHandle} has no ${methodName} method exposed. ` +
            `This might be caused by a typo or because you tried to use a deprecated API. ` +
            `Take a look at the code: https://github.com/decentraland/kernel/search?q=callRPC`
        )
      }
      return api[methodName].apply(api, args)
    },

    onStart(cb: Function) {
      that.onStartFunctions.push(cb)
    },

    error(message: string, data: any) {
      that.onError(Object.assign(new Error(message), { data }))
    }
  }
}
